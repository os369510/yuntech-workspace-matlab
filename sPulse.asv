#define S_FUNCTION_LEVEL 2
#define S_FUNCTION_NAME sPulse
#include "simstruc.h"
#include <math.h>
static void mdlInitializeSizes(SimStruct *S)  //flag 0
{
       ssSetNumSFcnParams(S,0);  // user's parameter unused
       if(ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) 
       {
         return ;  // check parameter
       } 
       {
         int_T i;
         if(!ssSetNumInputPorts(S,3)) return ;// set input 3 port 
         for(i=0;i<3;i++)
         {
           ssSetInputPortWidth(S,i,-1);
           ssSetInputPortDirectFeedThrough(S,i,1);
         }
       }
       {
         int_T i;
         if(!ssSetNumOutputPorts(S,2))return; // set output 2 port
         for(i=0;i<2;i++)
         {
            ssSetOutputPortWidth(S,i,-1);
         }
       }
       
       ssSetNumSampleTimes(S,1);
       ssSetNumRWork(S,0);
       ssSetNumIWork(S,0);
       ssSetNumPWork(S,0);
       ssSetNumModes(S,0);
       ssSetNumNonsampledZCs(S,0);
       
       ssSetOptions(S,SS_OPTION_EXCEPTION_FREE_CODE);
}

static void mdlInitializeSampleTimes(SimStruct *S) //
{
       ssSetSampleTime(S,0,ssGetInputPortSampleTime(S,1));
               //INHERITED_SAMPLE_TIME);
    ssSetOffsetTime(S,0,0.0);
}

double compute(double i,int value){
    double result=0;
    result=i/value;
    return result;
}
static void mdlOutputs(SimStruct *S,int_T tid) //flag 3
{
       int_T l=0;
       int_T i;
       int_T k;
       int_T y1Width = ssGetOutputPortWidth(S,0);
       int_T y2Width = ssGetOutputPortWidth(S,1);
       real_T *y1 = ssGetOutputPortRealSignal(S,0);
       real_T *y2 = ssGetOutputPortRealSignal(S,1);
       
       InputRealPtrsType uPtrs0 = ssGetInputPortRealSignalPtrs(S,0);
       InputRealPtrsType uPtrs1 = ssGetInputPortRealSignalPtrs(S,1);
       InputRealPtrsType uPtrs2 = ssGetInputPortRealSignalPtrs(S,2);
       
       double clock,pulse,constant;
       clock=*uPtrs0[0];
       pulse=*uPtrs1[0];
       constant=*uPtrs2[0];
       
   //    for(i=0;i<y2Width;i++)
   //    {
           for(l=0;l<299;l++){
               double FirstR=0,LastR=0;
               FirstR=compute(l,60);
               LastR=compute(((2*l)+1),120);
           
                   if((clock>=FirstR)&&(clock<LastR))
                       *y1=pulse;
                   if((clock>=
                       *y2=pulse;
           }
      // }
       //y2[0]=pulse;
       //for(k=0;k<y1Width;k++){ 
            
         //  y2[i]=clock;
        //  y1[k]=pulse;
       //}
       /*
       for(i=0;i<y1Width;i++)
       {
           if((clock>=(i/60))&&(clock<((i/60)+(1/120))))  // i/60 = 2*180*i/(360*60)
               y1[i]=pulse;
           else
               y1[i]=constant;
       }       */
     /*  for(i=0;i<y2Width;i++)
       {
           if((clock>=((i/60)-(1/120))) && (clock<(i/60)))
               y2[i]=pulse;
           else
               y2[i]=constant;
       }*/
}
static void mdlTerminate(SimStruct *S) //flag 9
{}
#ifdef MATLAB_MEX_FILE
#include "simulink.c"
#else
#include "cg_sfun.h"
#endif 
